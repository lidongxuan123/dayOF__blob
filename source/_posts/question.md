---
title: 问题汇总
date: 2020-06-08 13:46:37
tags: 问题汇总
categories:
- 问题汇总
---

1. 打印相关的
if ([]) {console.log(1);}
if ([].length) {console.log(2);}
if ({} === {}) {console.log(3);}
if ('' == 0) {console.log(4);} 
> 链接地址：https://www.cnblogs.com/frostbelt/p/3425498.html
// 1,4会被打印
（1）typeOf [] == object object判断的时候会转为true
（2）空数组的length为0，则隐式转换为false
（3）
（4）空字符串代表着false, 0 代表了false ，结果为true

2. 基本类型/引用类型
基本类型：Undefined、Null、String、Number、Boolean。
引用类型：object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)。
基本类型的变量是存放在栈区的，（栈区指内存里的栈内存）
引用类型的值是同时保存在栈内存和堆内存中的对象
栈内存：存储的值的大小是固定的
        由程序自动向操作系统申请分配以及回收，速度块使用方便，
堆内存：存储的值的大小不固定的
       程序员向系统申请一块内存，当系统收到程序的申请时，会遍历一个记录空闲内存地址的链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。分配的速度较慢，地址不连续，容易碎片化。

3.html的父级
    <html> 标签告知浏览器这是一个 HTML 文档。
    html 元素是 HTML 文档中最外层的元素。
    html 元素也可称为根元素。
4.三次握手和四次挥手
连接地址：https://www.cnblogs.com/bj-mr-li/p/11106390.html
> 序列号seq:占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有字节都编上一个序号，第一个序号由本地随机产生；给字节编上序号后，就给每一个报文指派一个序号，迅雷和seq就是这个报文段中的第一个字节的数据编号
> 确认号ack:占四个字节》期待收到对方下一个报文段的第一个数据字节的序号，序列号表示报文段携带数据的第一个字节的编号，而却确认号指的是希望接收下一个字节的编号，因此当前报文段最后一个的编号+1即为确认号。
> 确认ACK: 占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
> 同步SYN: 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
> 终止FIN:用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
> 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）
> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
四次挥手：
1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

5.Vue双向绑定原理
vue数据双向绑定是通过数据劫持结合发布者-订阅者模式来实现的。
因为vue是通过Object.defineProperty()来实现数据劫持的。

MVVM: M:模型  V:视图
数据更新视图的重点是如何知道数据变了，是通过Object.defineProperty()对属性设置一个set函数，当数据改变了就会触发这个函数，所以我们只要将一些需要更新的 方法放在这里面就可以实现data更新view了
首先对数据进行劫持监听，所以需要设置一个监听器Observer,用来监听所有属性，如果属性发生变化，就告诉订阅者watcher看是否需要更新，因为订阅者有多个，所以需要要给消息订阅器DEP来专门收集这些订阅者，我们还需要一个指令解析器comlile,对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者watcher,并替换模板数据或者绑定相应的函数，

observer ---> Dep --->订阅者 --->更新视图
                      解析器 --->更新视图
解析器compile实现步骤：
1.解析模板指令，并替换模板数据，初始化视图
2.将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器

6. 宏任务和微任务/宏循环和微循环
宏任务和微任务属于一个队列，主要却别在于它们的执行顺序，宏任务执行完如果有可执行的微任务则执行完微任务才会继续执行下一个宏任务
宏任务：包括整体代码script, setTimeout setInterval setImmediate
微任务：原生Promise（有些实现的promise将then方法放到了宏任务中）、process.nextTick、MutationObserver

settimeout 在0ms后将callback加入到宏任务的队列中，而promise的回调放在微任务的队列中
当前JS线程中的任务执行完成后（正常代码都会放入执行栈中，执行栈空闲后）queue中的函数会按队列执行，先去微任务的queue,再去执行宏任务队列中的callback

7. 从输入链接到浏览器页面呈现都经历了什么
第一步：获取ip地址，发送一个UDP的包给DNS服务器，DNS服务器会返回IP地址，浏览器会把IP地址进行缓存，下次访问会加快。
DNS中递归查询和迭代查询的区别：
递归查询：一般客户机和服务器之间属于递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到转换后的结果转交给客户机。
第二步：三次握手，与服务器建立连接
第三步： 握手成功后，浏览器向服务器发送http请求，请求数据包
第四步： 服务器处理收到的请求，将数据返回至浏览器
第五步：浏览器收到http响应
读取页面内容，浏览器渲染，解析html源码
生成Dom树，解析css样式，js交互







